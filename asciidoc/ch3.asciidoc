[[jwsur_3_chapter_3]]
== RESTful Web Services: The Client Side

Consider a familiar scenario in which a client accesses a RESTful web service:

* The client issues a GET request against a RESTful service. In general, a request to a RESTful service
targets a  named resource, with a URI as the name.

* If successful, this GET request results in a response document, a representation of the resource targeted in
the request. The document is usually in XML or JSON, although other formats might be available. In any case, the
response should be MIME-typed.

* The client extracts from the document whatever information is required for the client's application logic.

For example, the client might be a jQuery script embedded in an HTML document. This client requests data, such 
as a product list, from a web service.
If the request succeeds, the client extracts relevant information; for instance, the client might extract the
name, category, price, and in-stock quantity of each product in the list. The client then processes the 
information is some appropriate way; for instance, the JavaScript client might build and display an HTML table that represents 
the product list, with one row per product.

Each step in this sample scenario poses a challenge. The GET request must be formatted properly and the
status code of the response should be inspected to determine whether the request succeeded and, if not, why not.
The toughest challenge for the client, however, may be extracting required information from the document: the client may have to
parse the returned document to get the information in a usable format. To build an HTML table from an XML document, for
example, a JavaScript client would need to extract information items as text 'without' the XML markup; and an XML parse
would be the standard way to extract such information. It would be easier on the JavaScript client received a JSON payload
so that the
XML parse could be avoided altogether. The +@WebServiceProvider+ service in Chapter
2 illustrates the problem of parsing XML because successful POST and PUT operations against this service must send, as an 
XML document, the data required to construct or edit an +Adage+; and the service code parses the document to extract the
+words+ that make up the +Adage+. A dominant theme in this chapter is how to avoid the explicit parsing of documents, XML or
JSON,  returned from RESTful services.

All of the CRUD verbs used in RESTful services pose challenges, although these differ in degree, for both the service and the client. 
This chapter focuses on the the client side and pays particular attention to the challenge of extracting
usable information from an HTTP response whose payload is an XML or JSON document. Some examples parse documents to
extract such information and other examples show how explicit parsing can be avoided. Java has various libraries,
standard and contributed, for dealing with XML and JSON documents; and the examples illustrate such libraries.

Web services in general purport to be language neutral. Accordingly, the proof of
the pudding is whether a client written in one language can consume, without undue fuss, a service written in a different
language. My first example illustrates how this can be done with a Perl client against a Java RESTful service. Most of 
the other examples focus on Java clients against various services, including two Java clients against Amazon's RESTful 
E-Commerce service. The E-Commerce examples highlight the complexities encountered in targeting real-world 
services.

=== A Perl Client against a Java RESTful Web Service

The Perl client (see <<Ex1>>) against the Java 'predictions2' RESTful service, implemented as an +HttpServlet+, makes
various calls that cover the CRUD operations. (The 'predictions2' service is from Chapter 2.)
Perl comes with most Unixy systems and is available on Windows (see, for
example, 'www.activestate.com'). Although Perl has a quirky syntax--it has been called 'line-noise interpreted' and even worse--its 
excellent libraries, standard and
contributed, more than compensate. In any case, the point of the example is to provide a first look 
at how a client interacts with a RESTful service. The 'curl' clients from the two previous chapters illustrated all of the 
CRUD operations against several services; and all of the CRUD requests received at least a minimal document in return. Yet the
'curl' utility is meant for making HTTP requests, not processing HTTP responses.
The Perl client takes the second step; that is, this client performs all of the CRUD operations and then highlights the challenge of
processing response documents. In the case of response documents in XML, the Perl client parses the XML to extract usable
information, in this case the +id+, +who+, and +what+ of a specified +Prediction+ or of the entire +PredictionsList+ returned from
the service. 
[[Ex1]]
.A Perl client making CRUD calls against the RESTful 'predictions2' service.
====
----
#!/usr/bin/perl -w

# packages
use strict;
use LWP;
use XML::XPath;
use List::MoreUtils qw(each_array);

my $baseUrl = 'http://localhost:8080/predictions2/';
my $ua = LWP::UserAgent->new;
runTests();

## Run CRUD tests against the service.
sub runTests {
    getTest($baseUrl);               ## GET all (xml)
    getTest($baseUrl . '?id=4');     ## GET one (xml)
    getTestJson($baseUrl);           ## GET all (json)
    getTestJson($baseUrl . '?id=4'); ## GET one (json)
    postTest($baseUrl);              ## POST
    getTest($baseUrl);               ## GET all (xml)
    putTest($baseUrl);               ## PUT
    getTest($baseUrl . '?id=4');     ## GET one (xml)
    deleteTest($baseUrl . '?id=31'); ## DELETE 
    getTest($baseUrl);               ## GET one (xml)
}
sub getTest {
    my ($url) = @_;
    my $request = HTTP::Request->new(GET => $url);
    my $response = $ua->request($request);
    handleResponse($response, \&parseXml); # pointer to a function
}
sub getTestJson {
    my ($url) = @_;
    my $request = HTTP::Request->new(GET => $url, 
				     HTTP::Headers->new('Accept' => 'application/json'));
    my $response = $ua->request($request);
    handleResponse($response, \&parseJson);
}
sub postTest {
    my ($url) = @_;
    my $request = HTTP::Request->new(POST => $url);
    $request->content_type('application/x-www-form-urlencoded');
    $request->content('who=TS Eliot&what=This is the way the world ends.');
    my $response = $ua->request($request);
    handleResponse($response, undef);
}
sub putTest {
    my ($url) = @_;
    my $request = HTTP::Request->new(PUT => $url);
    $request->content_type('application/x-www-form-urlencoded');
    $request->content('id=4#who=FOOBAR');
    my $response = $ua->request($request);
    handleResponse($response, undef);
}
sub deleteTest {
    my ($url) = @_;
    my $request = HTTP::Request->new(DELETE => $url);
    my $response = $ua->request($request);
    handleResponse($response, undef);
}
sub parseXml {
    my ($rawXml) = @_;
    # print "Raw XML resonse:\n" . $rawXml . "\n";
    # Set up the XPath search.
    my $xp = XML::XPath->new(xml => trim($rawXml));
    # Extract a list apiece of ids, whos, and whats.
    my @ids = $xp->find('//object/void[@property="id"]/int')->get_nodelist;
    my @whos = $xp->find('//object/void[@property="who"]/string')->get_nodelist;
    my @whats = $xp->find('//object/void[@property="what"]/string')->get_nodelist;
    # Iterate over the lists to print the data.
    my $it = each_array(@ids, @whos, @whats);
    while (my ($id, $who, $what) = $it->()) {
	print sprintf("%2d: ", $id->string_value) . 
	    $who->string_value . " -> '" . 
	    $what->string_value . "'\n";
    }
}
sub parseJson {
    my ($json) = @_;
    print "JSON document:\n$json\n";
    # ...
}
sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}
sub handleResponse {
    my ($response, $callback) = @_;
    if ($response->is_success) {
	if (defined $callback) {
	    $callback->($response->content);
	}
	else {
	    print $response->content . "\n";
	}
    }
    else {
	print STDERR $response->status_line . "\n";
    }
}
----
====
The Perl client can make a GET request for all predictions or just a specified one; and the client can
express a preference for XML or JSON in either case. Here is the function +getTest+, which requests
all predictions in XML:
----
sub getTest {
    my ($url) = @_;                                <1>
    print "\nGET request against $url\n\n";
    my $request = HTTP::Request->new(GET => $url); <2>
    my $response = $ua->request($request);         <3>
    handleResponse($response, \&parseXml);         <4>
}
----
In line 1 the +$url+ variable (in Perl, a scalar variable starts with a +$+) has, as its value, a string URL that
targets the 'predictions2' service, whose
GET operation is the +doGet+ method in the +HttpServlet+. The Perl client generates, in line 2, a request object (the reference 
is +$request+) and then issues this request through a +LWP::UserAgent+ instance, with +$ua+ as the
reference (line 3). The client then invokes, in line 4, the function named +handleResponse+ with two arguments: the +$response+ 
reference, which gives access to the entire HTTP response, including the status code, the headers, and the
body; and a reference to a response-processing function, in this case +parseXml+, which parses the returned XML if
the request succeeds.

The function +parseXml+ illustrates the challenge of extracting usable information from the XML payload.
Perl, like most general-purpose languages, has various ways to parse XML. In this example, the Perl +XPath+ library is
used. Here is the parsing function without the comments:
----
sub parseXml {
  my ($rawXml) = @_;
  print "Raw XML resonse:\n" . $rawXml . "\n"; # raw xml                         <1>
  my $xp = XML::XPath->new(xml => trim($rawXml));                                <2>
  my @ids = $xp->find('//object/void[@property="id"]/int')->get_nodelist;        <3>
  my @whos = $xp->find('//object/void[@property="who"]/string')->get_nodelist;   <4>
  my @whats = $xp->find('//object/void[@property="what"]/string')->get_nodelist; <5>
  my $it = each_array(@ids, @whos, @whats);
  while (my ($id, $who, $what) = $it->()) {
    print sprintf("%2d: ", $id->string_value) . $who->string_value . " -> '" . 
	      $what->string_value . "'\n";
  }
}
----
The function prints the raw XML from the 'predictions2' service (line 1) and then uses +XPath+ (line 2) to
get three lists: +@ids+, +@whos+, and +@whats+ (lines 3, 4, and 5). (Perl lists begin with +@+.) The
+while+ loop then prints the text representation of each +Prediction+, giving the values of its
+id+, +who+, and +what+ properties. Here is a slice of the output:
----
 1: Cornelius Tillman -> 
    'Managed holistic contingency will grow killer action-items.'
 2: Conner Kulas -> 
    'Vision-oriented zero administration time-frame will generate back-end interfaces.'
...
23: Lottie Marks -> 
    'Open-source multi-tasking time-frame will monetize rich partnerships.'
----
In a production example, the application logic might be considerably more complicated than simply
printing the extracted information. The extracted +Prediction+ instances might be inserted into
a database, mined for relevant patterns, integrated with other information, sent out as email
greetings, and so on. Nonetheless,
the XML parsing would be the first step in support of any such additional processing.

The other requests from the Perl client are very similar to the 'curl' commands used in Chapter 1 and
Chapter 2. For example, the 'predictions2' service returns JSON rather than XML on a GET request if
the appropriate header element is in the HTTP message. The Perl client inserts the +Accept+ key/value
pair, issues the request, and then parses the returned JSON (line 1):
----
my $request = HTTP::Request->new(GET => $url, 
                         HTTP::Headers->new('Accept' => 'application/json')); <1>
my $response = $ua->request($request);
handleResponse($response, \&parseJson);
----

A POST or a PUT request requires that relevant data about a +Prediction+ be inserted into the
body of the HTTP request. Here is the POST test:
----
sub postTest {
    my ($url) = @_;
    my $request = HTTP::Request->new(POST => $url);
    $request->content_type('application/x-www-form-urlencoded');            <1>
    $request->content('who=TS Eliot&what=This is the way the world ends.'); <2>
    my $response = $ua->request($request);                                  <3> 
    handleResponse($response, undef); # undef means no callback function    <4>
}
----
Line 1 sets the content type of the HTTP request for +x-www-form-urlencoded+, the standard type 
for the body of a POST request; this type is commonly abbreviated as the 'HTTP form'. The form holds 
two key/value pairs, one for the +who+ and the other
for the +what+ property of a +Prediction+ (line 2). Line 3 sends the request and awaits the response. In line 4, 
the call to +handleResponse+, the Perl value +undef+ (short for 'undefined') serves roughly the same purpose
as +null+ in Java. In the call to +handleResponse+, a second argument with +undef+ as its value signals that the 
HTTP response should be
printed rather than processed further; for example, on a successful POST the printed response would be similar to:
----
<?xml version="1.0" encoding="UTF-8"?> 
<java version="1.7.0" class="java.beans.XMLDecoder"> 
  <string>Prediction 36 created.</string> 
</java> 
----
The Perl example illustrates language neutrality in RESTful web services because the 'predictions2' service is
written in Java. At the same time, this example 
focuses on a central question in this chapter: How can a RESTful client minimize or even 
avoid XML/JSON parsing? Even the relatively short Perl client makes clear that the tricky code involves XML 
parsing, although the Perl +XPath+ library has an API that eases the task.
The next section addresses the issue of response-document parsing with two examples, each a Java client against the Amazon E-Commerce service.
The first client contends with the XML that the Amazon service returns, whereas the second client uses JAX-B to transform the XML into
native Java objects, which are then manipulated with the familiar 'get/set' methods.

=== A Client against the Amazon E-Commerce Service

Amazon Web Services (AWS at 'aws.amazon.com') is an umbrella for Amazon's pioneering contributions, in infrastructure
and applications, to web services. From early on, Amazon has pushed hard to make its web sites for shopping, storage (S3, Simple Storage Service),
utility-priced cloud computing (EC2), and so on available as web services, too. Among the prominent hosts of web services, Amazon is
unusual in offering both SOAP-based and REST-style versions of such services. This chapter and later ones have code examples that
involve Amazon's E-Commerce or shopping service (see <<register_amazon>>), which requires an 'accessId' and a 'secretKey' for access.
The 'accessId' is inserted, as is, into any request against the E-Commerce service; and the 'secretKey' is
used to create what Amazon calls a 'signature', which is likewise inserted into every request and then verified on the
Amazon side. The 'secretKey' itself is not inserted into a request.

[[register_amazon]]
.Registering with Amazon
[options="header"]
****
Amazon's E-Commerce web service is free of charge but requires registration ('affiliate-program.amazon.com'). 
In particular, a web service client requires both
an 'access key id' ('accessId' for short) and a 'secret access key' ('secretKey' for short), each of which comes from Amazon 
after registration. The sample clients against the E-Commerce service, in this and later chapters, require the
'accessId' and the 'secretKey' as command-line arguments.
****

The +RestfulAmazon+ client (see <<Ex2>>) is relatively clean code but only because the messy details are isolated in the
utility class +RequestHelper+. Amazon requires, in a RESTful request for item lookups against the E-Commerce service, that
the verb be GET and that the required data be in a strictly formatted query string. Here are some details:

* The keys in the query string must be in lexicographical order with respect to the first byte in the key's name. 
* The query string must include a ISO-8601 timestamp.
* The query string must be URL-encoded under RFC 3986.
* The query string must include a 'hash-based message authentication code' using the SHA-256 hash algorithm. This hash value
is what Amazon calls the 'signature'.
* The authentication code must be base64 encoded.

Amazon's RESTful service is fussy about the format of requests against it. The utility class +RequestHelper+ ensures that
a GET request against the E-Commerce service has the required query-string format.
[[Ex2]]
.The +RestfulAmazon+ client against the Amazon E-Commerce web service.
====
----
package restful;

import java.net.URL;
import java.net.URLConnection;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.ByteArrayInputStream;
import java.util.HashMap;
import java.util.Map;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class RestfulAmazon {
    private static final String endpoint = "ecs.amazonaws.com";
    private static final String itemId = "0545010225"; // Harry Potter        <1>

    public static void main(String[ ] args) {
	if (args.length < 2) {
	    System.err.println("RestfulAmazon <accessKeyId> <secretKey>");
	    return;
	}
	new RestfulAmazon().lookupStuff(args[0].trim(), args[1].trim());
    }
    private void lookupStuff(String accessKeyId, String secretKey) {
        RequestHelper helper = new RequestHelper(endpoint, accessKeyId, secretKey);
        String requestUrl = null;
        String title = null;
	// Store query string params in a hash.
        Map<String, String> params = new HashMap<String, String>();
        params.put("Service", "AWSECommerceService");
        params.put("Version", "2009-03-31");
        params.put("Operation", "ItemLookup");                                <2>
        params.put("ItemId", itemId);
        params.put("ResponseGroup", "Small");
	params.put("AssociateTag", "kalin");  // any string should do
        requestUrl = helper.sign(params);
	String response = requestAmazon(requestUrl);
	// The string "null" is returned before the XML document.
	String noNullResponse = response.replaceFirst("null", "");
	System.out.println("Raw xml:\n" + noNullResponse);
	System.out.println("Author: " + getAuthor(noNullResponse));
    }
    private String requestAmazon(String stringUrl) {
	String response = null;
	try {
	    URL url = new URL(stringUrl);
	    URLConnection conn = url.openConnection();
	    conn.setDoInput(true);
	    BufferedReader in = 
		new BufferedReader(new InputStreamReader(conn.getInputStream()));
	    String chunk = null;
	    while ((chunk = in.readLine()) != null) response += chunk;
	    in.close();
	}
	catch(Exception e) { throw new RuntimeException("Arrrg! " + e); }
	return response;
    }
    private String getAuthor(String xml) {
	String author = null;
	try {
	    ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
	    DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();
	    fact.setNamespaceAware(true); 
	    DocumentBuilder builder = fact.newDocumentBuilder();
	    Document doc = builder.parse(bais);                                 
	    NodeList results = doc.getElementsByTagName("Author");
	    for (int i = 0; i < results.getLength(); i++) {
		Element e = (Element) results.item(i);
		NodeList nodes = e.getChildNodes();
		for (int j = 0; j < nodes.getLength(); j++) {
		    Node child = nodes.item(j);
		    if (child.getNodeType() == Node.TEXT_NODE) 
			author = child.getNodeValue();
		}
	    }
	}
	catch(Exception e) { throw new RuntimeException("Xml bad!", e); }
	return author;
    }
}
----
====
The +RestfulAmazon+ application expects two command-line arguments, an Amazon 'accessId' and
'secretKey' in that order. The client application then sets various properties such as the
requested Amazon operation (in this example, +ItemLookup+ of line 2), the item's identifier (in this
example, +0545010225+ in line 1, which is a Harry Potter novel), the Amazon associate's name, and so on.
After the +RequestHelper+ utility formats the request according to Amazon's requirements, the
+RestfulAmazon+ client then opens a +URLConnection+ to the Amazon service, sends the GET request,
and then reads the response,
chunk by chunk. The relevant code segment is:
----
URL url = new URL(stringUrl);
URLConnection conn = url.openConnection();                            <1>
conn.setDoInput(true);
BufferedReader in =                                                   <2>
  new BufferedReader(new InputStreamReader(conn.getInputStream()));
String chunk = null;
while ((chunk = in.readLine()) != null) response += chunk;            <3> 
----
The code first creates a +URLConnection+ (line 1) and then wraps a
+BufferedReader+ around the connection's +InputStream+ (line 2). A +while+ loop
is used to read the Amazon response chunk by chunk (line 3).
On a successful GET request, the payload in HTTP response body is an XML document. Here is
a slice from a sample run:
-----
<?xml version="1.0" ?>
<ItemLookupResponse 
   xmlns="http://webservices.amazon.com/AWSECommerceService/2011-08-01">
  <OperationRequest>
    <HTTPHeaders>
      <Header Name="UserAgent" Value="Java/1.7"></Header>
    </HTTPHeaders>
    <RequestId>591ac8db-0435-4c53-9b01-e3756ea9c55d</RequestId>
    <Arguments>
      <Argument Name="Operation" Value="ItemLookup"></Argument>
      <Argument Name="Service" Value="AWSECommerceService"></Argument>
      ...
      <Argument Name="ResponseGroup" Value="Small"></Argument>
    </Arguments>
    <RequestProcessingTime>0.0083090000000000</RequestProcessingTime>
  </OperationRequest>
  <Item>
    <Request>
      <IsValid>True</IsValid>
      <ItemLookupRequest>
	<IdType>ASIN</IdType>
	<ItemId>0545010225</ItemId>
        ...
      </ItemLookupRequest>
    </Request>
    <Item>
      <ASIN>0545010225</ASIN>
      <DetailPageURL>
        http://www.amazon.com/Harry-Potter-Deathly-Hallows-Book...
      </DetailPageURL>
      <ItemLinks>
	<ItemLink>
	  <Description>Technical Details</Description>
	  <URL>http://www.amazon.com/Harry-Potter-Deathly-Hallows-Book...</URL>
	</ItemLink>
        ...
	<ItemLink>
	  <Description>Add To Wedding Registry</Description>                    <1>
	  <URL>http://www.amazon.com/gp/registry/wedding/add-item.html...</URL>
	</ItemLink>
        ...
      </ItemLinks>
      <ItemAttributes>
	<Author>J. K. Rowling</Author>
	<Creator Role="Illustrator">Mary GrandPr√©</Creator>
	<Manufacturer>Arthur A. Levine Books</Manufacturer>
	<ProductGroup>Book</ProductGroup>
	<Title>Harry Potter and the Deathly Hallows (Book 7)</Title>
      </ItemAttributes>
    </Item>
  </Items>
</ItemLookupResponse>
----
Even a cursory look at the XMl makes clear, to anyone who has searched on the Amazon web site, that
the web service response contains essentially the same information as the corresponding HTML page viewed
in a browser visit. For example, there is an XML element labeled 
----
Add To Wedding Registry (line 1)
----
Amazon's goal is to make the web site and the web service deliver
the same information and the same functionality but in different format: the web site delivers
HTML documents, whereas the web service delivers XML documents.

With the response XML in hand, the +RestfulAmazon+ client then parses the document to extract, as
proof of concept, the author's name, J. K. Rowling. The code uses the relatively old-fashioned
DOM (Document Object Model) parser, implemented as the standard Java +DocumentBuilder+ class. 
Here is the relevant code segment:
----
Document doc = builder.parse(bais);                        <1>         
NodeList results = doc.getElementsByTagName("Author");     <2>
for (int i = 0; i < results.getLength(); i++) {
   Element e = (Element) results.item(i);
   NodeList nodes = e.getChildNodes();
      for (int j = 0; j < nodes.getLength(); j++) {
         Node child = nodes.item(j);
         if (child.getNodeType() == Node.TEXT_NODE)        <3>
           author = child.getNodeValue();
      }
}
----
The code first builds the DOM tree structure from the Amazon response bytes (line 1) and
then gets a list, in this case a list of one element, from DOM elements tagged as +Author+.
The author's name, J. K. Rowling, occurs as the contents of a +TEXT_NODE+ (line 3). The
parse deals with the usual complexities of the tree structure that a DOM represents.
Similar DOM searches could extract from Amazon's XML response document any other information of interest,
for example, the book's ISBN number.
[[Ex3]]
.The utility class +RequestHelper+, which supports the +RestfulAmazon+ class.
====
----
package restful;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedMap;
import java.util.TimeZone;
import java.util.TreeMap;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class RequestHelper {
    private static final String utf8 = "UTF-8";
    private static final String hmacAlg = "HmacSHA256";
    private static final String requestUri = "/onca/xml";
    private static final String requestMethod = "GET";
    private String endpoint = null;
    private String accessKeyId = null;
    private String secretKey = null;
    private SecretKeySpec secretKeySpec = null;
    private Mac mac = null;

    public RequestHelper(String endpoint, 
			 String accessKeyId, 
			 String secretKey) {
        if (endpoint == null || endpoint.length() == 0)
	    throw new RuntimeException("The endpoint is null or empty."); 
        if (null == accessKeyId || accessKeyId.length() == 0) 
            throw new RuntimeException("The accessKeyId is null or empty."); 
        if (null == secretKey || secretKey.length() == 0)   
            throw new RuntimeException("The secretKey is null or empty."); 
        this.endpoint = endpoint.toLowerCase();
        this.accessKeyId = accessKeyId;
        this.secretKey = secretKey;
	try {                                                                    <1>
	    byte[ ] secretKeyBytes = this.secretKey.getBytes(utf8);
	    this.secretKeySpec = new SecretKeySpec(secretKeyBytes, hmacAlg);
	    this.mac = Mac.getInstance(hmacAlg);
	    this.mac.init(this.secretKeySpec);
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    public String sign(Map<String, String> params) {             
        params.put("AWSAccessKeyId", this.accessKeyId);                          <2>
        params.put("Timestamp", this.timestamp());                               <3>
        // The parameters need to be processed in lexicographical order, with
        // sorting on the first byte: a TreeMap is perfect for this.
        SortedMap<String, String> sortedParamMap =                               <4>
           new TreeMap<String, String>(params);  
        // Ensure canonical form of the query string, as Amazon REST is fussy.
        String canonicalQS = this.canonicalize(sortedParamMap);                  <5>
	// Prepare the signature with grist for the mill.
        String toSign = 
            requestMethod + "\n" 
            + this.endpoint + "\n"
            + requestUri + "\n"
            + canonicalQS;
        String hmac = this.hmac(toSign);
        String sig = null;
	try {
	    sig = URLEncoder.encode(hmac, utf8);
	}
	catch(UnsupportedEncodingException e) { System.err.println(e); }
        String url =                                                             <6>
            "http://" + this.endpoint + requestUri + "?" + canonicalQS + 
            "&Signature=" + sig;
        return url;
    }
    public String sign(String queryString) {
        Map<String, String> params = this.createParameterMap(queryString);
        return this.sign(params);
    }
    private String hmac(String stringToSign) {
        String signature = null;
        byte[ ] data;
        byte[ ] rawHmac;
        try {
            data = stringToSign.getBytes(utf8);
            rawHmac = mac.doFinal(data);
            Base64 encoder = new Base64();                                               <7>
            signature = new String(encoder.encode(rawHmac));
        } 
	catch (UnsupportedEncodingException e) {
            throw new RuntimeException(utf8 + " is unsupported!", e);
        }
        return signature;
    }
    // Amazon requires an ISO-8601 timestamp. 
    private String timestamp() {
        String timestamp = null;
        Calendar cal = Calendar.getInstance();
        DateFormat dfm = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
        dfm.setTimeZone(TimeZone.getTimeZone("GMT"));
        timestamp = dfm.format(cal.getTime());
        return timestamp;
    }
    private String canonicalize(SortedMap<String, String> sortedParamMap) {
        if (sortedParamMap.isEmpty()) return "";
        StringBuffer buffer = new StringBuffer();
        Iterator<Map.Entry<String, String>> iter = sortedParamMap.entrySet().iterator();
	while (iter.hasNext()) {
	    Map.Entry<String, String> kvpair = iter.next();
	    buffer.append(encodeRfc3986(kvpair.getKey()));
	    buffer.append("=");
	    buffer.append(encodeRfc3986(kvpair.getValue()));
	    if (iter.hasNext()) buffer.append("&");
	} 
        return buffer.toString();
    }
    // Amazon requires RFC 3986 encoding, which the URLEncoder may not get right.
    private String encodeRfc3986(String s) {
        String out;
        try {
            out = URLEncoder.encode(s, utf8)
                .replace("+", "%20")
                .replace("*", "%2A")
                .replace("%7E", "~");
        } 
	catch (UnsupportedEncodingException e) { out = s; }
        return out;
    }
    private Map<String, String> createParameterMap(String queryString) {
        Map<String, String> map = new HashMap<String, String>();
        String[ ] pairs = queryString.split("&");
        for (String pair : pairs) {
            if (pair.length() < 1) continue;
            String[ ] tokens = pair.split("=", 2);
            for(int j = 0; j < tokens.length; j++) {
                try {
                    tokens[j] = URLDecoder.decode(tokens[j], utf8);
                } 
		catch (UnsupportedEncodingException e) { }
            }
            switch (tokens.length) {
                case 1: {
                    if (pair.charAt(0) == '=') map.put("", tokens[0]);
                    else map.put(tokens[0], "");
                    break;
                }
                case 2: {
                    map.put(tokens[0], tokens[1]);
                    break;
                }
            }
        }
        return map;
    }
}
----
====
The +RequestHelper+ class (see <<Ex3>>) has one job: to format the HTTP GET request in accordance with Amazon's
strict requirements. This class acts as a utility that hides many low-level details but a quick
overview should provide some insight in what the E-Commerce service requires in a well-formed request.
Recall a request against the E-Commerce service requires both an 'accessId' and a 'secretKey' but
the two play quite different roles in the request. The 'accessId' occurs as a value in a key/value pair, with
+AWSAccessKeyId+ as the key (line 2). There is also a key/value pair for the timestamp that the E-Commerce
service requires (line 3); hence, the 'accessId' and the timestamp are peers. Amazon uses the timestamp to
ensure that the requests are timely, that is, recently constructed. 

The 'secretKey' plays a different role than does the 'accessId'. The 'secretKey' is used to initialize a 
'message authentication code' (MAC), which the Java +javax.crypto.Mac+ class represents. (The initialization occurs in the +try+
block that begins on line 1.)
Amazon requires a particular type of MAC, an HMAC (hash-based message authentication code) that uses the
SHA-256 algorithm (Secure Hash Algorithm that generates a 256-bit hash). The important security point is
that the 'secretKey' itself does not go over the wire from the client to Amazon. Instead the 'secretKey'
is used to initialize the process that generates a message digest (hash value). Finally, this hash value is
encoded in base64 (line 7). Amazon calls the result a 'signature', which occurs as the value in a key/value pair
whose key is +Signature+ (line 6). 

There is a final preparatory step. The E-Commerce service expects, in a GET request, that the query-string 
key/value pairs be in sorted order. The +RequestHelper+ uses a +TreeMap+, as this data structure is ideally
suited for the task (line 4). The properly formatted query string results from a call to +canonicalize+; and
this query string is then appended to the base URL for the Amazon E-Commerce service.

Not every commercial site is as fussy as Amazon when it comes to request formatting. This first
Amazon example shows that generating a correctly formatted RESTful request may be non-trivial.
This client also explicitly parses the returned XML. The next client
addresses the issue of how to avoid such parsing. Before looking at the code for the second client,
however, it will be useful to focus on the JAX-B utilities used in the second client.

=== A Standalone JAX-B Example

Recall that the 'B' in 'JAX-B' stands for data 'binding', the associating of a Java data type such as +String+ to
an XML Schema (or equivalent) type, in this case +xsd:string+. There are built-in bindings for the Java
primitive types such as +int+ and +double+ together with +String+ and +Calendar+; arrays (including +Collections+) of any such 
types; and programmer-defined types that reduce, via properties, to any of the preceding. The surprising omission is the
+Map+, a collection of key/value pairs; but a +Map+ is readily handled as two coordinated collections: a collection of
'keys' and a corresponding collection of 'values'. An example of JAX-B in action may help to drive these points
home.

The +Skier+ class (see <<Ex4>>) is annotated with +@XmlRootElement+ to inform the JAX-B utilities that
a +Skier+ instance should be 
transformed into an XML document that has +skier+ as its root or 'document'
(that is, outermost) element. In the default Java naming convention, the
root element is the lowercase version of the class name; hence, +Skier+ 
becomes +skier+. The annotation could be amended
----
@XmlRootElement(name = "NordicSkier")
----
so that the root element has a specified name, in this example +NordicSkier+.

[[Ex4]]
.The annotated +Skier+ POJO class.
====
----
import javax.xml.bind.annotation.XmlRootElement;
import java.util.Collection;

@XmlRootElement        
public class Skier  {    
    private Person person;    
    private String nationalTeam; 
    private Collection majorAchievements;
    public Skier() { } // required for unmarshaling
    public Skier (Person person, 
		  String nationalTeam, 
		  Collection<String> majorAchievements) {
        setPerson(person);
	setNationalTeam(nationalTeam);
	setMajorAchievements(majorAchievements);
    }
    // properties
    public Person getPerson() { return this.person; }
    public void setPerson (Person person) { this.person = person; }
    
    public String getNationalTeam() { return this.nationalTeam; }
    public void setNationalTeam(String nationalTeam) {        
        this.nationalTeam = nationalTeam;
    }    
    public Collection getMajorAchievements() { return this.majorAchievements; }
    public void setMajorAchievements(Collection majorAchievements) {
        this.majorAchievements = majorAchievements;
    }
}
----
====
The +Skier+ class has a property of programmer-defined type +Person+ (see <<Ex5>>), which
in turn is a POJO class with three properties: +name+, +age+, and +gender+. 
Two of +Person+ properties are of Java type +String+, which binds to
XML type +xsd:string+. The third +Person+ property is of Java type
+int+, which binds to the XML type +xsd:int+.
[[Ex5]]
.The annotated +Person+ POJO class with three properties.
====
----
import javax.xml.bind.annotation.XmlType;

@XmlType       
public class Person  {
    private String name;
    private int    age;
    private String gender;
        
    public Person() { }
    public Person(String name, int age, String gender){
	setName(name);
	setAge(age);
	setGender(gender);
    }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age;  }
    public void setAge(int age) { this.age = age; }
    public String getGender() { return gender; }
    public void setGender(String gender) { this.gender = gender; }
}
----
====
The annotation +XmlType+ declares that a +Person+ instance can be transformed into
an XML type, a type that an XML Schema specifies in detail. The upshot of the
annotated +Skier+ and +Person+ classes is this: an in-memory +Skier+ object, which
encapsulates a +Person+, can be transformed into a single XML document, whose
root element is tagged +skier+; and the +skier+ document encapsulates a +person+ element.

The application class +Marshal+ (see <<Ex6>>) does the following:

* Creates a +Skier+ instance.

* Marshals this instance into an XML document, which is 
saved to a file and also printed to the standard output.

* Unmarshals the XML document in the file into a separate +Skier+ instance, an
instance that effectively clones the original +Skier+ instance.

Recall that, in this context, 'marshaling' is the process of serializing an in-memory object into an XML document;
and 'unmarshaling' is the inverse process of creating an in-memory object from an XML document.

[[Ex6]]
.The +Marshal+ application that marshals and unmarshals a +Skier+.
====
----
import java.io.File;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.IOException;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.JAXBException;
import java.util.List;
import java.util.ArrayList;

class Marshal {
    private static final String fileName = "bd.mar";

    public static void main(String[ ] args) {
	new Marshal().runExample();
    }
    private void runExample() {
        try {
	    JAXBContext ctx = JAXBContext.newInstance(Skier.class);   <1>
	    Marshaller m = ctx.createMarshaller();                    <2>
	    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
	    // Marshal a Skier object: 1st to stdout, 2nd to file
	    Skier skier = createSkier();              
	    m.marshal(skier, System.out);
	    FileOutputStream out = new FileOutputStream(fileName);
	    m.marshal(skier, out);                                    <3>
	    out.close();
	    // Unmarshal as proof of concept
	    Unmarshaller u = ctx.createUnmarshaller();                <4>
	    Skier bdClone = (Skier) u.unmarshal(new File(fileName));
	    System.out.println();
	    m.marshal(bdClone, System.out);
	} 
	catch(JAXBException e) { System.err.println(e); }
	catch(IOException e) { System.err.println(e); }
    }
    private Skier createSkier() {
	Person bd = new Person("Bjoern Daehlie", 49, "Male");
        List<String> list = new ArrayList<String>();
	list.add("12 Olympic Medals");
        list.add("9 World Championships");                
        list.add("Winningest Winter Olympian");                       
	list.add("Greatest Nordic Skier");
        return new Skier(bd, "Norway", list);
    }
}
----
====
In the +Marshal+ class, the critical step is the creation of a +JAXBContext+ (line 1), in this
case a structure built from Java reflection on the type +Skier+. (The one-argument method +newInstance+
can take, as its argument, a single class or a package identifier.) The utility class +JAXBContext+ then
guides the marshaling and unmarshaling: the +Marshaller+ and the +Unmarshaller+ are created
with +JAXBContext+ methods (lines 2 and 4). By the way, there is no agreement about whether 
'marshaling' and 'unmarshaling' should be spelled with one 'l' or two.

The marshaling (line 3) produces an XML document (see <<Ex7>>) that serves as the source of the
unmarshaling (line 4). The only complexity is in the elements tagged +majorAchievement+, which include
three attributes apiece. The reason is that a +majorAchievement+ is, in Java, a
+Collection+ type--in particular an +ArrayList<String>+. The corresponding XML type is
an array of +xs:string+ objects; and the +majorAchievement+ elements cite the
XML Schema grammar (lines 1 and 2), which includes rules about arrays. By default, the Java
marshaling produces an XML document in which the properties of the source Java object
are in alphabetical order.
[[Ex7]]
.The XML document generated from marshaling a sample +Skier+.
====
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<skier>
    <majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  <1>
                       xmlns:xs="http://www.w3.org/2001/XMLSchema"            <2>
                       xsi:type="xs:string">12 Olympic Medals
    </majorAchievements>
    <majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                       xmlns:xs="http://www.w3.org/2001/XMLSchema" 
                       xsi:type="xs:string">9 World Championships
    </majorAchievements>
    <majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                       xmlns:xs="http://www.w3.org/2001/XMLSchema" 
                       xsi:type="xs:string">Winningest Winter Olympian
    </majorAchievements>
    <majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                       xmlns:xs="http://www.w3.org/2001/XMLSchema" 
                       xsi:type="xs:string">Greatest Nordic Skier
    </majorAchievements>
    <nationalTeam>Norway</nationalTeam>
    <person>
        <age>49</age>
        <gender>Male</gender>
        <name>Bjoern Daehlie</name>
    </person>
</skier>
----
====
This JAX-B example implies, of course, that the conversion between Java and XML could be
automated. Accordingly, a Java client against a RESTful service could:

* Issue a request whose response is an XML document.
* Use JAX-B to unmarshal the XMl document into a Java object.
* Manipulate the Java object in the usual ways (for instance, with 'get/set' methods) to serve the 
application logic.

In this scenario, the XML is transparent. The second Amazon example goes into the details of how this
can be done. First, however, an alternative to the standard Java XML utilities deserves a look.

==== The XStream Option

Java comes with standard packages for Java-to-XML conversions and XML-to-JSON conversions. There are also 
various  contributed libraries, among them XStream ('xstream.codehaus.org'). This section examines the 
XStream option for serializing Java objects to XML/JSON documents and deserializing Java objects from
such documents. XStream includes a persistence API and has extensions in support of the Hibernate ORM (Object
Relation Mapper). Among the more interesting features of XStream is that its API does not center on the
'get/set' methods that define Java properties. XStream can serialize into XML an instance of a Java class that
has nothing but +private+ fields. XStream emphasizes its ease of use, which the following examples try to capture.

[[Ex7a]]
.An +XStream+ example with a class that has no properties.
====
----
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;

public class PersonNoProps  {
    private String name;
    private int    age;
    private String gender;

    public PersonNoProps(String name, int age, String gender){
	this.name = name;
	this.age = age;
	this.gender = gender;
    }
}
class Main {
    public static void main(String[ ] args) {
	PersonNoProps bd = new PersonNoProps("Bjoern Daehlie", 49, "Male");
	// setup
	XStream xstream = new XStream(new DomDriver());                  <1>
	xstream.alias("skier", PersonNoProps.class); // for readability  <2>
	// serialize
	String xml = xstream.toXML(bd);                                  <3>
	System.out.println(xml);
	// deserialize and confirm
	PersonNoProps bdClone = (PersonNoProps) xstream.fromXML(xml);    <4>
	System.out.println(xstream.toXML(bdClone));
    }
}
----
====
The +PersonNoProps+ class (see <<Ex7a>>) illustrates the ease of +XStream+ use. The class has three
+private+ fields and only a three-argument constructor; of interest is that the class has
no properties, that is, no +public+ 'get/set' methods. Nonetheless, an instance of the +PersonNoProps+ 
class can be serialized or deserialized straightforwardly. Line 1 in the code listing constructs an
+XStream+ instance with a DOM driver. Line 2 provides an alias for the document element's
tag, in this case +skier+. If an alias were not provided, then the document element would have a tag
named after the class; hence, line 2 is optional. The serialization in line 3 and the
deserialization in line 4 are quick and easy. The output for both +println+ calls is
----
<skier>
  <name>Bjoern Daehlie</name>
  <age>49</age>
  <gender>Male</gender>
</skier>
----
The generated XML is minimalist. Compiling and running this code requires the core +XStream+ packages,
which come in a single JAR file: 'xstream.jar'.

The first +XStream+ example begins with the serialization of an entire +PersonNoProps+ instance and
ends with the deserialization of a clone. +XStream+ also supports selective or fine-grained
serialization and deserialization. The next example (see <<Ex9a>>) illustrates.
[[Ex9a]]
.The +PersonPropsConverter+ class for customized marshaling.
====
----
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

public class PersonPropsConverter implements Converter {
    public boolean canConvert(Class c) {
	return c.equals(PersonProps.class);                    <1>
    }
    // As proof of concept, marshal/unmarshal only the name.
    public void marshal(Object object, 
			HierarchicalStreamWriter writer,
                        MarshallingContext context) {
	PersonProps person = (PersonProps) object;
	writer.startNode("Person"); 
	writer.setValue(person.getName());                     <2>
	writer.endNode();
    }
    public Object unmarshal(HierarchicalStreamReader reader,
			    UnmarshallingContext context) {
	PersonProps person = new PersonProps();
	reader.moveDown();
	person.setName(reader.getValue());                     <3>
	reader.moveUp();
	return person;
    }
}
----
====
The +PersonPropsConverter+ class (see <<Ex9a>>) serializes and deserializes, as proof of concept, only one 
property in a +PersonProps+ instance: the +name+ property. An implementation of the +Converter+ interface
must define three methods:

* +canConvert+: This method (line 1) returns a +boolean+ to indicate which types are eligible for the customized
serialization and deserialization defined in the methods +marshal+ and +unmarshal+ (lines 2 and 3,
respectively). In this example, an object must be of type +PersonProps+ (see <<Ex10a>>), which includes any descendants of this
class, in order to be convertible.

* +marshal+: This method (line 2) supports customized serialization (marshaling) of a +PersonProps+ object. In
the current example, only the person's +name+ property is serialized but any subset of the properties, including
all of them, could be serialized.

* +unmarshal+: This method (line 3), the inverse of +marshal+, supports customized deserialization (unmarshaling).

[[Ex10a]]
.The code to illustrate customized +XStream+ marshaling/unmarshaling.
====
----
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;

public class PersonProps {
    private String name;
    private int    age;
    private String gender;

    // constructor
    public PersonProps() { }
    // properties
    public void setName(String name) { this.name = name; }         <1>
    public String getName() { return this.name; }
    public void setAge(int age) { this.age = age; }                <2>
    public int getAge() { return this.age; }
    public void setGender(String gender) { this.gender = gender; } <3>
    public String getGender() { return this.gender; } 
}

class Main {
    public static void main(String[ ] args) {
	// Create a person and set only the name.
	PersonProps person = new PersonProps();
	person.setName("Bruno");
	XStream xstream = new XStream(new DomDriver());
	xstream.registerConverter(new PersonPropsConverter());     <4>
	xstream.alias("name", PersonProps.class);
	String xml = xstream.toXML(person);                        <5>
	System.out.println(xml);
	PersonProps clone = (PersonProps) xstream.fromXML(xml);    <6>
	System.out.println(clone.getName()); // Bruno
    }
}
----
====
The +PersonProps+ class (see <<Ex10a>>) revises the +PersonNoProps+ class by adding properties. 
The  revised class has
three conventional Java properties, each defined as a pair of 'get/set' methods. The 
properties are +name+ (type +String+) in line 1, +age+ (type +int+) in line 2, and +gender+ (type +String+)
in line 3. The
revised class has a no-argument constructor. 

The tester class +Main+ creates an +XStream+ instance as before but now registers a
customized +Converter+ (line 4), a +PersonPropsConverter+ (see <<Ex9a>>). In the
call to +toXML+ (line 5), the customized converter takes over and serializes only the
+name+ property. The output is:
----
<person>
  <name>Bruno</name>
</person>
----
The deserialization (line 6) creates a new +PersonProps+ instance and sets the +name+ property
to +Bruno+. The other properties, +age+ and +gender+, have the default values for fields, in
this case +0+ and +null+, respectively.

The core +XStream+ library also supports the conversion of Java objects to and from JSON. There
are various JSON drivers available in this library, the simplest of which is the 
+JsonHierarchicalStreamDriver+. This driver supports the serialization of Java objects to JSON
but not the inverse operation. If deserialization from JSON to Java is needed, then a driver such
as Jettison ('jettison.codehaus.org') is a good choice because it interoperates cleanly with
+XStream+. 
[[Ex11a]]
.An example of +XStream+ serialization to JSON.
====
----
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;
import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;

public class JsonTest {
    public static void main(String[ ] args) {
	PersonNoProps bd = new PersonNoProps("Bjoern Daehlie", 49, "Male");
	XStream xstream = new XStream(new JsonHierarchicalStreamDriver());  <1>
	String json = xstream.toXML(bd); // it's really toJson now          <2>
	System.out.println(json);
    }
}
----
====
The +JsonTest+ code (see <<Ex11a>>) illustrates basic JSON serialization in +XStream+. An +XStream+
instance now is constructed with a JSON driver (line 1), in this case an instance of
a +JsonHierarchicalStreamDriver+, which comes with the core +XStream+ JAR file.
The serializing method is still named +toXML+ (line 2) but the output is JSON rather
than XML because of the JSON driver. Here is the output:
----
{"PersonNoProps": {
  "name": "Bjoern Daehlie",
  "age": 49,
  "gender": "Male"
}}
----
+XStream+ supports customized JSON serialization. For example, a programmer might not want
the root element +PersonNoProps+ included in the JSON; and the JSON serializer can be
programmed to exclude this element.

The +XStream+ API is remarkably low-fuss but likewise powerful. This API has gained steadily in
popularity among Java developers who are looking for quick and easy ways to convert between Java objects, on the
one side, and either XML or JSON documents, on the other side.

The JAX-B and +XStream+ examples illustrate serialization from Java to XML or JSON and deserialization from
XML or JSON to Java. In the context of clients against RESTful web services, the deserialization side of
the coin is of primary interest because these clients need to process the response payloads, in XML or JSON,
that come from the RESTful service. Accordingly, the next section returns to Amazon's E-Commerce service but
this time with the goal of hiding the XML that this service returns in response to a successful HTTP request.

=== Another Client against the Amazon E-Commerce Service

The second client against the Amazon E-Commerce service does not deal explicitly with any XML but otherwise has
the same functionality as the first client. 
The steps for setting up the second client are listed below but
the ZIP file with the sample code includes an JAR 'Amazon2.jar' that can be executed directly:
----
% java -jar Amazon2.jar <accessId> <secretKey>
----
Here are the steps for setting up the second Amazon client, steps that would be copied for a Java client against
any RESTful service that provides an XML Schema--and most services do provide a schema. For a depiction of the
process and the role of Java's 'xjc' utility, see <<xjc>>.

[[xjc]]
.Using the 'xjc' utility to transform an XML Schema into Java classes.
====
----
+------------+         
| E-Commerce |     +-------------+      +------------------------+
| XML Schema +---->| xjc utility |----> | generated Java classes |
|            |     +-------------+      +------------------------+
+------------+
----
====

* Download the XMl Schema for the E-Commerce service. The URL is:
+
----
webservices.amazon.com/AWSECommerceService/AWSECommerceService.xsd
----
+
The downloaded schema is about 55K in size. (This is the same schema used in the SOAP-based versions of the Amazon services.)  
Put the downloaded document in a 
local file such as 'amazon2/amazon.xsd'. The local file name is arbitrary.

* The 'amazon.xsd' needs some tweaking so that the Java JAX-B utilities can use this file without
complaining. The downloaded XML Schema begins as follows:
+
----
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema  
  xmlns:xs="http://www.w3.org/2001/XMLSchema"                              <1>
  xmlns:tns="http://webservices.amazon.com/AWSECommerceService/2011-08-01" 
  targetNamespace=
    "http://webservices.amazon.com/AWSECommerceService/2011-08-01" 
  elementFormDefault="qualified">
  <xs:element name="Bin">                                                  <2>
    <xs:complexType>                                                       <3>
      <xs:sequence>                                                        <4>
      ...
----
+
The problem lies with the namespace identifier +xs+, which occurs once to the right of the colon (line 1) in 
+
----
xmlns:xs="http://www.w3.org/2001/XMLSchema"
----
+
on the second line and everywhere else to the left of the colon (lines 2, 3, and 4). The identifier +xs+ should be
changed globally to +xsd+; any reasonable text editor can make this change. The result should be:
+
----
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema 
  xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns:tns="http://webservices.amazon.com/AWSECommerceService/2011-08-01" 
  targetNamespace=
    "http://webservices.amazon.com/AWSECommerceService/2011-08-01" 
  elementFormDefault="qualified">
  <xsd:element name="Bin">
    <xsd:complexType>
      <xsd:sequence>
      ...
----
+
The 'xjc' utility should not be this brittle, of course; Java itself generates schemas that use the
namespace abbreviation +xs+.

* Execute the 'xjc' utility, which ships with the core Java JDK, against the schema. 
In this example, the command is:
+
----
% xjc -p restful2 amazon.xsd
----
+
The '-p' flag stands for 'package'. The 'xjc' utility creates the package/subdirectory named
'restful2' and fills the subdirectory with, at present, 84 Java source files. The files have 
names such as 'CartAddRequest.java', 'ItemLookup.java', 'ItemSearch.java', 'LoyaltyPoints.java', and so on. 
These files, in compiled form, are the Java types that correspond to the XML Schema types in 'amazon.xsd'.

* This step is optional but recommended for convenience. Copy the source files 'RestfulAmazon.java' and 
'RequestHelper.java' from the first Amazon 
example into the 'restful2' subdirectory. The package name in both files needs to change 
from +restful+ to +restful2+. The 'xjc'-generated files could be kept in a 
separate package, of course.

* Compile the '.java' files in 'restful2'.

The nearly 85 Amazon files in 'restful2' have JAX-B annotations such as +@XmlType+. These
'xjc'-generated files automate the translation between an XML data type such as
+tns:ItemSearch+ and the corresponding Java type, in this case +restful2.ItemSearch+.
The XML types are defined in the Amazon schema and the corresponding Java types are the
classes generated with the 'xjc' utility.
The process (see <<xjc>>) of generating Java artifacts is relatively uncomplicated. 

Programming involves trade-offs and the revised Amazon client illustrates one such
trade-off. On the plus side, the revised +RestfulAmazon+ client no longer needs 
'explicitly' to parse XML; hence,
the various +import+ directives that support DOM parsing can be removed because the +getAuthor+
method no longer uses the imported types such as +DocumentBuilder+ and +NodeList+. On the minus 
side, the 'xjc'-generated classes bring a new API into play; and this API involves
some Russian-doll nesting, as a look at the new code will show.

The revised client requires no changes to the +RequestHelper+ except for the change in the package
name. The revised +RestfulAmazon+ client (see <<Ex8>>) is largely the same as the original; hence, 
unchanged code is marked with an ellipsis.

[[Ex8]]
.The revised +RestfulAmazon+ that uses JAX-B to avoid XML parsing.
====
----
package restful2;

...
import javax.xml.transform.stream.StreamSource; 
import javax.xml.validation.SchemaFactory;      
import javax.xml.validation.Schema;             
import javax.xml.XMLConstants;                  
import javax.xml.validation.Validator;         
import javax.xml.bind.JAXBContext;           
import javax.xml.bind.Marshaller;           
import javax.xml.bind.Unmarshaller;        
import javax.xml.bind.JAXBException;     

public class RestfulAmazon {
    ...
    public static void main(String[ ] args) {
       ...
    }
    private void lookupStuff(String accessKeyId, String secretKey) {
       ...
    }
    private String requestAmazon(String string_url) {
        ...
    }
    private String getAuthor(String xml) {
      String author = null;
      try {
        // Create an XML Schema object
        final String fileName = "amazon.xsd"; // downloaded XML Schema 
        final String schemaUri = XMLConstants.W3C_XML_SCHEMA_NS_URI;   
        SchemaFactory factory = SchemaFactory.newInstance(schemaUri);  
        Schema schema = factory.newSchema(new StreamSource(fileName));          <1>
        // Create a JAX-B context for unmarshaling
        JAXBContext ctx = JAXBContext.newInstance(ItemLookupResponse.class);    <2>
        Unmarshaller um = ctx.createUnmarshaller();                             <3>
        um.setSchema(schema);                                                   <4>
        // Generate a Java ItemSearchResponse instance.
        ItemLookupResponse ilr = (ItemLookupResponse) 
             um.unmarshal(new ByteArrayInputStream(xml.getBytes()));            <5>
        // Use the standard POJO idiom to extract the author.
        List<Items> itemsList = ilr.getItems(); // list of lists                <6>
        for (Items items : itemsList) {         // outer list                   <7>
          List<Item> list = items.getItem();  // inner list                     <8>
          for (Item item : list) {            // items in inner list  
            ItemAttributes attributes = item.getItemAttributes();   
            List<String> authors = attributes.getAuthor(); // could be several     
            author = authors.get(0); // in this case, only one                  <9>
          }
        }
      }
      catch(JAXBException e ) { throw new RuntimeException(e); } 
      catch(Exception e) { throw new RuntimeException(e); }      
      return author;
    }
}
----
====
In the revised +RestfulAmazon+ client, the +getAuthor+ method is invoked with an XML
document as the argument but the XML is not parsed. Instead, the method does the
following:

* A +JAXBContext+ is used to get information about the class of interest, in this
case the 'xjc'-generated class, +ItemLookupResponse+ (line 2). This class represents
the E-Commerce response from a lookup operation against the service.

* The +JAXBContext+ instance is used to create an unmarshaler (line 3), which then
is initialized with the E-Commerce schema (lines 1 and 4).

* The unmarshaler transforms the bytes from the E-Commerce response document, which 
is XML, into an instance of the +ItemLookupResponse+ class. At this point, there is 
no need to parse any XML because the +ItemLookupResponse+ object can be used instead
to find desired information, in this case the author's name.

* In the current example, the +RestfulAmazon+ client looks up only one item, a book. In
general, however, a look-up request against the E-Commerce service might yield
many hits instead of just one. At the data structure level, the result is lists nested
inside lists; hence, code lines 6 through 8 work from the outermost to the innermost list.
Here, for a closer look, is the looping in isolation:
+
----
List<Items> itemsList = ilr.getItems(); // list of lists        <1>                    
for (Items items : itemsList) {         // outer list                          
   List<Item> list = items.getItem();   // inner list                          
      for (Item item : list) {          // items in inner list  <2>
         ItemAttributes attributes = item.getItemAttributes();  <3>
            List<String> authors = attributes.getAuthor(); 
            author = authors.get(0); // in this case, only one  <4>
      }
}
----
+
The +getItems+ method encapsulated in the +ItemLookupResponse+ object returns a +List<Items>+ (line 1)
but each
element in this list is itself a list. In the second +for+ loop (line 2), individual 
items are finally available; indeed, in this response there is exactly one
such +Item+, whose +ItemAttributes+ (line 3) include the name of the author, J. K. Rowling. Her name
occurs as the first and only name in a list of authors (line 4) because, of course, even a single
book might have multiple authors.

The two clients against the Amazon RESTful service highlight a typical choice confronted
in programming RESTful clients. The choice can be summarized as follows:

* Should the client deal directly with the returned XML (or JSON), using parsing and
similar tools to extract the required information?

* Should the client invest in utilities such as JAX-B that can hide the XML but thereby
require the client to work in yet another API?

Is there a compelling answer to either question? For one-off client
applications, working directly with the XML may be the way to go. Tools such as 
+XPath+ make it relatively easy to extract information from XML documents, at least XML
documents that are of a reasonable size. It is very hard to define 'reasonable size' in
this context, of course. The problem is that tools such as +XPath+ require a DOM--a tree structure--in
order to work. Building a tree from, say, an XML stream of gigabyte size may be
prohibitively slow; and searching the built tree may be the same.
For client applications that regularly target a particular service such as 
Amazon E-Commerce, working with JAX-B artifacts means working in familiar Java idioms
such as 'get/set' methods. The benefit of using JAX-B is that
the XML effectively disappears into the JAX-B infrastructure.

=== The CTA Bus Tracker Services

The Amazon web sites for shopping, storage, and cloud computing are rich in content and 
functionality--and the corresponding web services inherit these very attributes. 
Amazon, moreover, is a pioneer and a major player in web services, SOAP-based and REST-style. 
Social networking sites such as Facebook, Twitter, and Tumblr 
support RESTful services against their sites. Indeed, the trend among any serious web sites, 
large or small, is to provide RESTful access and an API in support of such access. For contrast,
this section considers a relatively recent and, in comparison with Amazon, a small-scale effort
at RESTful web services: bus-tracking at the CTA (Chicago Transit Authority).

The Amazon E-Commerce service has a standard design in that a single service encapsulates
many operations, for instance, operations to search, look up, order, clear a shopping cart, 
and so on. 
The CTA takes a different approach in that each service consists of a 
single operation; and there is a separate XML Schema per service. The services are thus
quite simple and the schemas range in size from about 12 to 36 lines in size. The
simplest service returns the current local time; more complicated services report on buses
en route and their routes, expected bus-arrival times at particular locations, vehicles in 
operation, and the like.
[[bus_tracker]]
.A sample client against the CTA's RESTful bus-tracking services.
====
----
package ctaBT;

import java.net.URL;
import java.net.URLConnection;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BusTracker {
    private static final String baseUrl = 
	"http://www.ctabustracker.com/bustime/api/v1/"; 

    public static void main(String[ ] args) {
	if (args.length < 1) {
	    System.err.println("BusTracker <CTA key>");
	    return;
	}
	new BusTracker().demo("?key=" + args[0]);
    }
    private void demo(String key) {
	// Current official CTA time.
	String url = baseUrl + "gettime" + key;
	makeRequest(url);
	url = baseUrl + "getvehicles" + key;
	makeRequest(url);
	String sampleRoute = "&rt=20&pid=954";
	url = baseUrl + "getpatterns" + key + sampleRoute;
	makeRequest(url);
    }
    private void makeRequest(String stringUrl) {
	String response = null;
	try {
	    URL url = new URL(stringUrl);
	    URLConnection conn = url.openConnection();
	    conn.setDoInput(true);
	    BufferedReader in = 
		new BufferedReader(new InputStreamReader(conn.getInputStream()));
	    String chunk = null;
	    while ((chunk = in.readLine()) != null) response += chunk;
	    in.close();
	}
	catch(Exception e) { throw new RuntimeException("Arrrg! " + e); }
	report(stringUrl, response);
    }
    private void report(String url, String xml) {
	String msg = url + "\n" + xml;
	System.out.println(msg);
    }
}
----
====

[[cta_key]]
.Registering with the CTA
****
The CTA bus-tracker web services are free of charge but do require registration ('www.ctabustracker.com'). A client
call against any service requires a 'key', which the CTA provides upon registration.
****

Use of the bus-tracking service, through the web site or a web service, requires a 'key' (see <<cta_key>>) from
the CTA. The key occurs as a query string attribute in a GET request, the only
type of HTTP request supported. The sample +BusTracker+ client (see <<bus_tracker>>) first targets the 'gettime' service
whose XML Schema is <<bus_schema>>.

[[bus_schema]]
.The XML Schema for the CTA time service.
====
----
<?xml version="1.0" encoding="utf-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="bustime-response" type=" bustime-response" />
  <xs:complexType name="bustime-response">
    <xs:sequence>
      <xs:element name="error" type="error" 
                  minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="tm" type="xs:string" 
                  minOccurs="0" maxOccurs="1"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="error">
    <xs:sequence>
      <xs:element name="msg" type="xs:string" 
                  minOccurs="1" maxOccurs="1"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>
----
====

On a successful GET request, the response is similar to
----
<?xml version="1.0"?>
<bustime-response>
  <tm>20130302 16:38:49</tm>
</bustime-response>
----

The invocation syntax for other services is only slightly more complicated. For example, the
GET request with this URL
----
http://www.ctabustracker.com/bustime/api/v1/getpatterns?key=...&rt=20&pid=954:
----
is asking for the traffic patterns of buses en route. A sample response would look like this:
----
<bustime-response>							
  <ptr>				
    <pid>954</pid>				
    <ln>40902.0</ln>				
    <rtdir>West Bound</rtdir>				
    <pt>						
      <seq>1</seq>						
      <lat>41.882134908777</lat>						
      <lon>-87.624528408051</lon>
    </pt>	
    ...
  </ptr>		
</bustime-response>		
----
The bus-tracker services are deliberately small and simple, which encourages developers to experiment
with composing other services out of these. The CTA services illustrate a refreshing trend to make
data available on web sites equally accessible through web services. The CTA itself currently has
a beta release of train-tracking services modeled after the bus-tracking ones.

=== RESTful Clients and WADL Documents

At the core of a SOAP-based service is the 'service contract', a WSDL 
(Web Service Description Language) document. WSDL is an XML dialect. In modern web services, the
WSDL plays the role that the IDL (Interface Definition Language) document plays in the DCE/RPC
services introduced in Chapter 1.
In any case, the WSDL document
has various sections, all of which are required except for the 'types' section that contains
an XML Schema or equivalent; and modern WSDLs almost always include a schema. The information
in the WSDL specifies the invocation syntax for every operation encapsulated in the service.
SOAP frameworks such as Java Metro and DotNet provide
tools that, given a WSDL, can generate client-side library code, which facilitates
the programming of a client against the service. The WSDL itself is language neutral and 
the publisher of the service typically generates at least the first draft of this service
contract, which then can be refined as needed. In principle a WSDL document could describe 
either a SOAP-based or a REST-style service; in practice, however, the WSDL is used predominantly
for SOAP-based services. Chapter 4, which introduces SOAP-based examples, looks closely at the WSDL document.
For now, the similarity between a WSDL document and a WADL document is of interest.

As noted, WSDL documents can describe either category of web service, SOAP-based or REST-style; but there seems
to be little interest in WSDLs and WSDL-based tools for RESTful services. JAX-RS implementations
such as Metro do provide a WSDL counterpart, the WADL (Web Application Description Language)
document that describes a JAX-RS service and can be used to generate client-side code. The 
'wadl2java' tool can be downloaded from 'wadl.java.net'. (The 'wadl2java' download includes
Unixy and Windows versions.) As the name indicates, this tool
generates Java code from a WADL document. The publisher of JAX-RS service generates the
WADL dynamically, although a WADL, like a WSDL, could be edited as needed--or even written from
scratch. The syntax for getting the WADL differs slightly among JAX-RS implementations. In the
Jersey implementation, the document is available as 'application.wadl'. As an example, recall the
'predictions3' JAX-RS service from Chapter 2 whose base URL is:
----
http://localhost:8080/predictions3/resourcesP/
----
The WADL document for this service is available under Jersey with the URL:
----
http://localhost:8080/predictions3/resourcesP/application.wadl
----
If the implementation were Apache CXF instead of Jersey, the URL would be:
----
http://localhost:8080/predictions3/resourcesP?wadl
----

The WADL document for the 'predictions3' service (see <<wadl>>) is a page or so in size. 
The document links the HTTP verb
for a CRUD operation with the URI for the code that implements the operation; and the 
document section also includes information about the parameters passed into the operation.
For example, here is a segment for creating a new +Prediction+ in the 'predictions3' service:
----
<resource path="/create">                                                <1>
   <method name="POST" id="create">                                      <2>
      <request>
         <representation mediaType="application/x-www-form-urlencoded">  <3>
            <param xmlns:xs="http://www.w3.org/2001/XMLSchema" 
                   type="xsd:string" style="query" name="who"/>
            <param xmlns:xs="http://www.w3.org/2001/XMLSchema" 
                   type="xsd:string" style="query" name="what"/>
         </representation>
      </request>
      <response>
         <representation mediaType="text/plain"/>                        <4>
      </response>
   </method>
</resource>
----
The +resource+ element (line 1) specifies the +path+ or URI, in this case +/create+, that identifies
the RESTful resource. Next comes the HTTP method (line 2), in this case POST, together with the
implementing Java method, in this case +create+. 
The 'wadl2java' utility gets the names
of the resource path and the implementing Java method from the source code.
The WADL segment also gives the MIME types of the request (line 3) and the
response (line 4): the request type +application/x-www-form-urlencoded+ specifies a URL-encoded
form (that is, collection of key/value pairs) in the body of the POST request; and the
response type +text/plain+ is, if the request succeeds, a confirmation message.

[[wadl]]
.The WADL document for the 'predictions3' JAX-RS web service.
====
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<application xmlns="http://wadl.dev.java.net/2009/02">
    <doc xmlns:jersey="http://jersey.java.net/" 
         jersey:generatedBy="Jersey: 1.10 11/02/2011 03:53 PM"/>
    <grammars/>
    <resources base="http://localhost:8080/predictions3/resourcesP/">
      <resource path="/">
        <resource path="/delete/{id: \d+}">
          <param xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                 type="xsd:int" style="template" name="id"/>
          <method name="DELETE" id="delete">
            <response>
              <representation mediaType="application/json"/>
            </response>
          </method>
        </resource>
        <resource path="/create">
          <method name="POST" id="create">
            <request>
              <representation mediaType="application/x-www-form-urlencoded">
                ...
              </representation>
            </request>
            <response>
               <representation mediaType="text/plain"/>
            </response>
          </method>
        </resource>
        ...
        <resource path="/xml/{id: \d+}">
          <param xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
		 type="xsd:int" style="template" name="id"/>
                <method name="GET" id="getXml">
                  <response>
                    <representation mediaType="application/xml"/>
                  </response>
                </method>
        </resource>
        <resource path="/json">
          <method name="GET" id="getJson">
            <response>
              <representation mediaType="application/json"/>
            </response>
          </method>
        </resource>
        <resource path="/json/{id: \d+}">
          <param xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
		 type="xsd:int" style="template" name="id"/>
          <method name="GET" id="getJson">
            <response>
              <representation mediaType="application/json"/>
            </response>
          </method>
        </resource>
        ...
    </resources>
</application>
----
====
The WADL document is language neutral but its use is confined basically to the Java world. Other languages
and frameworks have their counterparts; for example, Rails has the +ActiveResource+ construct that lets
a client program interact with a service but without dealing explicitly with documents in XML or JSON. The 
'wadl2java' utility serves the same general purpose for the Java programmer.

WADL-derived code (see <<Ex11>>) is not everyday Java code, as the class named +Localhost_Predictions3ResourcesP+
indicates.
This code, like most that comes from utilities,
is not pretty but does support a Java client against the JAX-RS 'predictions3' service. Perhaps the best way to
appreciate the usefulness of the 'wadl2java' tool is to program a 'predictions3' client that uses the
'wadl2java'-generated artifacts.

[[Ex11]]
.A segment of the Java source file generated with the 'wadl2java' utility.
====
----
package predictions3;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Generated;
import javax.ws.rs.core.UriBuilder;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.GenericType;
import com.sun.jersey.api.client.WebResource;
...
public class Localhost_Predictions3ResourcesP {
    public final static URI BASE_URI;
    static {
        URI originalURI = URI.create("http://localhost:8080/predictions3/resourcesP/");
        java.io.InputStream is = 
	  Localhost_Predictions3ResourcesP.class.getResourceAsStream(
            "/META-INF/jax-rs-catalog.xml");
        if (is != null) {
          ...
        }
        BASE_URI = originalURI;
    }
    ...
    public static class Root {
        public Localhost_Predictions3ResourcesP.Root.DeleteIdD deleteIdD(String idD) {
            return new Localhost_Predictions3ResourcesP.Root.DeleteIdD(_client, 
                _uriBuilder.buildFromMap(_templateAndMatrixParameterValues), idD);
        }
        public Localhost_Predictions3ResourcesP.Root.Create create() {
            return new Localhost_Predictions3ResourcesP.Root.Create(_client, 
                 _uriBuilder.buildFromMap(_templateAndMatrixParameterValues));
        }
        public Localhost_Predictions3ResourcesP.Root.Update update() {
            return new Localhost_Predictions3ResourcesP.Root.Update(_client, 
                 _uriBuilder.buildFromMap(_templateAndMatrixParameterValues));
        }
        ...
        public static class Create {
            private Client _client;
            private UriBuilder _uriBuilder;
            private Map<String, Object> _templateAndMatrixParameterValues;
            private URI _uri;

            public Create(Client client, URI uri) {
                _client = client;
                _uri = uri;
                _uriBuilder = UriBuilder.fromUri(uri);
                _uriBuilder = _uriBuilder.path("/create");
                _templateAndMatrixParameterValues = new HashMap<String, Object>();
            }
            ...
            public<T >T postXWwwFormUrlencodedAsTextPlain(Object input, 
                                                          GenericType<T> returnType) {
                UriBuilder localUriBuilder = _uriBuilder.clone();
                WebResource resource = 
                   _client.resource(localUriBuilder.buildFromMap(
                                    _templateAndMatrixParameterValues));
                com.sun.jersey.api.client.WebResource.Builder resourceBuilder = 
                   resource.getRequestBuilder();
                resourceBuilder = resourceBuilder.accept("text/plain");
                ...
                return response.getEntity(returnType);
            }
            ...
        }
        ...
}
----
====

.From the 'predictions3.wadl' file to the 'wadl2java'-generated classes
[options="header"]
****
The 'wadl2java' utility for Jersey downloads from 'wadl.java.net' as a ZIP file, which includes
sample Ant and Maven scripts that can be adapted as needed. (The sample Ant script builds client-support
code for the Yahoo News Service, a RESTful service that Yahoo no longer publishes.) Let 'WADL_HOME' be
the base directory for the contents of the unzipped file. 'WADL_HOME' has a 'bin' subdirectory, with 'wadl2java' 
utilities for Unixy and Windows systems; and a 'lib' directory that contains almost all of the JAR files
required. The missing JAR file, as of version WADL 1.1.3, is 'jersey-bundle.jar', which should be copied into the
'WADL_HOME/lib' directory.

The Jersey-generated WADL document for the 'predictions3' service uses +xs+ instead of +xsd+ as a namespace
identifier. Here are the first two occurrence in 'predictions.wadl', with one +xs+ to the left of the colon
and the other to the right:
----
<param xmlns:xs="http://www.w3.org/2001/XMLSchema" 
       type="xs:int" 
...       
----
The +xs+ should be changed globally to +xsd+. 

Compiling a 'wadl2java'-generated file such as 'Localhost_Predictions3ResourcesP.java' requires
two JAR files: 'jersey-bundle.jar' and 'jersey-core.jar'. The ZIP file that contains the sample code
includes the Ant script 'runWADL.xml', which compiles and executes the WADL-based client against the
'predictions3' service.
****
The +Predictions3Client+ (see <<Ex12>>) is the source code for a sample client against the 'predictions3' JAX-RS service. 
For convenience, the
client is in the same package, +predictions+, as the 'wadl2java'-generated code. The +Predictions3Client+ underscores
again the trade-off in using a tool such as 'wadl2java' to avoid dealing explicitly with XML or similar
payloads:

* The upside is avoiding an XML or comparable parse.
* The downside is learning yet another API.

[[Ex12]]
.The +Predictions3Client+, which uses the 'wadl2java'-generated classes.
====
----
package predictions3;

import java.net.URI;

public class Predictions3Client {
    public static void main(String[]  args) {
	new Predictions3Client().demo();
    }
    private void demo() {
	// Get a reference to the Localhost_Predictions3ResourcesP.Root defined
	// inside Localhost_Predictions3ResourcesP, as the "root" provides access
	// to other classes, which in turn support the CRUD functionalities.
	Localhost_Predictions3ResourcesP.Root root =                         <1>
           Localhost_Predictions3ResourcesP.root();
	// The xmlGetter can make GET requests against the service.
	Localhost_Predictions3ResourcesP.Root.Xml xmlGetter = root.xml();    <2>
	String xml = xmlGetter.getAsXml(String.class); // String returned    <3>
	System.out.println("The raw XML:\n" + xml);    // predictions in XML 
    }
}
----
====
The set-up in the +Predictions3Client+ seems clumsy because the 'wadl2java'-generated artifacts
are nested +static+ classes, an idiom that is uncommon in quotidian Java. The good news
is that, once the clumsiness recedes, the method calls are refreshingly simple. For instance,
the calls to the +root+ (line 1) and +xml+ (line 2) methods take no arguments and the call to 
+getAsXml+ (line 3) takes but one argument, the Java type for the returned XML document.
The 'wadl2java'-generated code would be even easier to use if XML Schema documents were 
produced with, for example, the +schemagen+ utility and then referenced in the +grammars+ section of
'predictions3.wadl', which is currently empty. With this refinement, the call to
----
xmlGetter.getAsXml(String.class)
----
could be changed to the friendlier
----
xmlGetter.getAsXml(PredictionsList.class)
----

Chapter 4 covers the WSDL document and WSDL-based utilities for generating helpful client-side code. At that point it will
be easier to assess the usefulness of WADL documents and the related utilities. For now, it is enough to name WADL-related
technologies as yet another part of the Java support for RESTful web services.

=== The JAX-RS Client API

JAX-RS, Restlet, and the JAX-WS +@WebServiceProvider+ frameworks for RESTful services include a client-side API. 
These APIs are meant to simplify the task of writing RESTful clients in general, not just clients against a 
RESTful service implemented in a particular framework. To underscore the point, this section takes a look
at the JAX-RS client-side API; the client, however, goes against the servlet-based 'predictions2' RESTful service
from Chapter 2. 

[[jaxrs_client]]
.A sample client using the JAX-RS client-side API.
====
----
package jerseyClient;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.WebResource;
import javax.ws.rs.core.MediaType;
import com.sun.jersey.api.representation.Form;

public class JerseyClient {
    private static final String baseUrl = "http://localhost:8080/predictions2";

    public static void main(String[ ] args) {
	new JerseyClient().demo();
    }
    private void demo() {
	Client client = Client.create();
	client.setFollowRedirects(true); // in case the service redirects
	WebResource resource = client.resource(baseUrl);
	getAllDemo(resource);
	postDemo(resource); // same resource but different verb
	String url = baseUrl + "?id=32";
	resource = client.resource(url);
	getOneDemo(resource);
	deleteDemo(resource); // delete id = 32
    }
    private void getAllDemo(WebResource resource) {
	// GET all XML
	String response = 
	    resource.accept(MediaType.APPLICATION_XML_TYPE).get(String.class);
	report("GET all in XML:\n", response);
	// GET all JSON
	response =
	    resource.accept(MediaType.APPLICATION_JSON_TYPE).get(String.class);
	report("GET all in JSON:\n", response);
    }
    private void getOneDemo(WebResource resource) {
	String response = 
	    resource.accept(MediaType.APPLICATION_XML_TYPE).get(String.class);
	report("GET one in XML:\n", response);
	response =
	    resource.accept(MediaType.APPLICATION_JSON_TYPE).get(String.class);
	report("GET one in JSON:\n", response);
    }
    private void postDemo(WebResource resource) {
	Form form = new Form(); // HTTP body, a simple hash
	form.add("who", "William Butler Yeats");
	form.add("what", "I know that I shall meet my fate");
	
	String response = 
	    resource.type(MediaType.APPLICATION_FORM_URLENCODED_TYPE)
	    .accept(MediaType.TEXT_PLAIN_TYPE)
	    .post(String.class, form);
	report("POST:\n", response);
    }
    private void deleteDemo(WebResource resource) {
	String response =
	    resource.accept(MediaType.TEXT_PLAIN_TYPE).delete(String.class);
	report("DELETE:\n", response);
    }
    private void report(String msg, String response) {
	System.out.println("\n" + msg + response);
    }
}
----
====
The +JerseyClient+ (see <<jaxrs_client>>) against the servlet-based 'predictions2' RESTful service, which
supports all of the CRUD operations. (An executable JAR with the client is included in the 
ZIP with the sample code.) This client underscores that the JAX-RS client API is not restricted to
JAX-RS services. 
In any case, the +JerseyClient+ uses some nice features of the
JAX-RS client-side API. For example, the 'predictions2' service uses same the URI in a GET request
that returns XML as in one that returns JSON. What differentiates the two requests  is that
the one for JSON has the key/value pair 
----
accept: application/json
----
or the equivalent in the HTTP headers of a GET request.
In the +getAllDemo+ method of the +JerseyClient+, the two forms of the GET request are
expressed at a high level:
----
resource.accept(MediaType.APPLICATION_XML_TYPE).get(String.class);  // XML
resource.accept(MediaType.APPLICATION_JSON_TYPE).get(String.class); // JSON
----
There is no need for the programmer to inject, using a low-level API, the 
----
accept: application/json
----
key/value pair into
the HTTP headers. By the way, the +get(String.class)+ at the end of each statement signals that
the response to the GET request should be text, a Java +String+. The API accepts JAX-B types as well so that,
for example, a GET request could indicate that it expects a +Prediction+ object rather than a +String+ one.

The setup for making CRUD calls is uncomplicated. A +Client+ instance is created, which then can be used to 
create arbitrarily many +WebResource+ instances, each of which wraps a URL. Here, for review, is a 
slice of the +JerseyClient+:
----
Client client = Client.create();
client.setFollowRedirects(true); // in case the service redirects
WebResource resource = client.resource(baseUrl); // service URL
----
In version 2, the JAX-RS client API introduces some advanced features such as
filters and asynchronous requests. These features will be examined in the next chapter but in the
context of SOAP-based web services. Restlet has a client API comparable to the one in JAX-RS. The JAX-WS 
client API for calls against the +@WebServiceProvider+ is at a lower level than both JAX-RS and Restlet. This
is appropriate in that the +@WebServiceProvider+ service-side API is deliberately low level. All of these
client-side APIs add a RESTful layer to the familiar Java classes such as +URLConnection+. 

=== JSON for JavaScript Clients

JavaScript clients, often written in a dialect such as jQuery, are now a major force in RESTful web services.
Gone are the bad old days during which a browser downloaded a page generated on the server and did no further client-side
processing. A modern web site typically integrates client-side and server-side processing to serve the 
overall goal of high performance combined with professional look-and-feel; and JavaScript--in a sense broad 
enough to encompass languages/frameworks such as Dojo, Enyo, Meteor, midori, jQuery, and SmartClient--is the 
dominant language for client-side processing. 

At one time, the data displayed on a HTML page typically came from a database through a server-side application down to 
a browser. Web services are now a prevalent source of data, a source accessible directly from a client-side script embedded 
in an HTML page. Data flows into an HTML page need not originate, at least not immediately, in a server-side application connected to a
database.  These changes further blur
the distinction between web sites and web services because the HTML pages that remain a key part of any web site embed
scripts that can act as web service clients. Pioneering JavaScript frameworks such as Meteor ('meteor.com') aim at
virtually collapsing the difference between client-side and server-side functionality by allowing client-side
scripts direct access to a server-side database. These changes and trends together open new possibilities for
web services and their clients; these changes likewise point to an even greater role for JavaScript processing and JSON
representations in web services.

==== JSONP and Web Services

Contemporary web services regularly support not only JSON payloads but also JSONP, where the *P* stands for 'with padding'. JSONP originally 
signified a way to work around
the traditional 'same domain policy' that prevents a page downloaded from a domain such as 'server.foo.org' from communicating
with a domain other than 'foo.org'; and JSONP still serves this purpose. 
The JSONP workaround involves +script+ elements in a page, as these elements allow code
to be downloaded from anywhere; and the downloaded code then can perform arbitrary processing, which
includes communicating with servers in arbitrary domains. JSONP works nicely with web services.

JSONP brings an event-driven API to client-side processing. Using JSONP, the programmer can do the following:

* Provide a URL to a data source.
* Specify a callback function to be executed, in browser context, once the data from the
specified source arrives.

[[twitter]]
.A JSONP call against the RESTful Twitter search.
====
----
<!DOCTYPE html>
<html>
<head>
    <title>Twittering</title>
    <script type = "text/javascript" 
	    src = "http://code.jquery.com/jquery-latest.min.js">
    </script>
    <script type = 'text/javascript'>
       function cBack(data) { alert(JSON.stringify(data)); } <1>
       (function($) {
          var url = "http://search.twitter.com/search.json?q=skiing&rpp=4";
          $.ajax({
             type: 'GET',
             url: url,
             async: false,
             jsonpCallback: 'cBack',                         <2>
             contentType: "application/json",
             dataType: 'jsonp',                              <3>
             success: function(json) { console.dir(json.sites); },
             error: function(e) { console.log(e.message); }
          });
       })(jQuery);
    </script>
</head>
<body></body>
</html>
----
====
The HTML document in <<twitter>> embeds jQuery code, which illustrates a JSONP call against Twitter's RESTful search service. 
The three code lines
of interest are numbered. The GET request to Twitter has +jsonp+ as its +dataType+ (line 3) and the
+jsonpCallback+ is a function named +cBack+ (lines 1 and 2) that takes one argument, the data returned
from the Twitter search. The Twitter response can be depicted in text as follows:
----
cBack({...})
----
This is the invocation syntax for a JavaScript function that takes one argument, a JavaScript object. (It 
should be noted that a JavaScript function is likewise a JavaScript 'object', as JavaScript treats
functions as first-class objects.)
The curly braces +{+ and +}+ mark the start and the end of the JavaScript argument to the function. This
argument is a mix of meta-data
about the search and a list (that is, a JavaScript array) of information about skiing images.
Here is a small slice of the argument, with personal data obscured with ellipses:
----
{"completed_in":0.009, "max_id":308446633115385860,
 ...
 "query":"skiing","refresh_url":"?
 ...
 [{"created_at": "Mon, 04 Mar 2013 05:19:42 +0000",
   "from_user": "...", "from_user_id": ...,
   "from_user_id_str": "...", "from_user_name" : "... ",
   "geo":null,
   ...
}
----
The JavaScript callback function +cBack+, upon receipt of the Twitter data, pops up an alert window 
that shows the text representation of the
downloaded JSON object. 

The JSONP exchange between the client-side script and the Twitter search service
can be summarized as follows. The script, written in the jQuery dialect of JavaScript, makes
a JSONP call that specifies a callback function; and the Twitter service accommodates by returning, as 
the HTTP response, 
the name of the callback function together with the requested data as the argument to the function. The
browser executes the function call, which displays the returned JSON in a popup window. This small example
thus illustrates the event-driven character of a JSONP request.

With respect to RESTful web services, JSON is an ideal format for JavaScript clients because JSON is the text
representation of a native JavaScript object. With two additional examples, this section covers the basics and sketches some possibilities.
The first example involves a 'composed' web service, that is, a service that includes
another service as a component. This example also illustrates a common task in web services--reformatting
data, in this case reformatting XML as JSON. The second example focuses on 'ajax' 
calls: jQuery embedded in an HTMl page regularly polls a server so that the partially updated page reflects the current
state of the resource.

==== A Composed RESTful Service with jQuery

The first jQuery example, named 'cds', is a composed RESTful service. Here is an overview:

* The HTML page, downloaded from the 'cds' service to a browser, contains embedded jQuery that makes 
a GET request against
'getCDs.jsp', a JSP script with support from a back-end JavaBean. This JSP script and the back-end bean 
together implement the web service that delivers JSON back to a jQuery or comparable script.

* The back-end JavaBean, an instance of the +FetchXML+ class, makes its own GET request, in this case against
a RESTful service that the W3C maintains. This service delivers a list of CD titles from the 1980s, in XML format, back to the
+FetchXML+ instance, which then converts the XML to JSON.

* The JSP script 'getCDs.jsp', with the JSON from the back-end bean, completes the service by sending the
JSON list of CDs back to the jQuery script embedded in the HTML page. Here is slice of the returned JSON:
+
----
[{"title":"empire burlesque",
  "price":10.9,
  "company":"columbia",
  "year":1985,
  "artist":"bob dylan",
  "country":"usa"},
 ...
----
+
* The jQuery script displays, as confirmation, the downloaded JSON in a pop-up window and then iterates over
the JSON array of CDs, displaying the +title+ and the +artist+ for each CD as an HTML element in an 
unordered list. The entire scenario (see <<cds_picture>>) consists of two GET requests and
two response payloads, one in XML and the ultimate one in JSON. 
[[cds_picture]]
.The composed 'cds' service.
====
-----
   +---------+   GET    +---------+   GET    +-----------+
   | jQuery  |--------->|   cds   |--------->|    W3C    |
   | script  |<---------| service |<---------|  service  |
   +---------+   JSON   +---------+   XML    +-----------+
     browser              server               W3C server
-----
====
Perhaps the best way to clarify the architecture is to start with the jQuery client, which expects
the data to come in JSON format. The catch is that the W3C service provides the data in XML format.
The intermediary 'cds' service takes on the job of format converter.

[[jquery_cds]]
.The jQuery RESTful client embedded in an HTML page.
====
----
<!DOCTYPE html>
<html>
  <head>
    <title>JSON</title>
    <script type = "text/javascript" 
	    src = "http://code.jquery.com/jquery-latest.min.js">
    </script>
    <script type = "text/javascript">
      $.getJSON('http://localhost:8080/cds/getCDs.jsp', function(response) {
         var cds = response.catalog.cd; 
         alert(JSON.stringify(cds));
         $.each(cds, function(ind, val) {                                      <1>
             $('#container').append('<li>' + cds[ind].title + ': ' +           <2>
	                                     cds[ind].artist + '</li>'); } );  <3>
      });
    </script>  
  </head>
  <body>
    <ul id = 'container'></ul>
  </body>
</html>
----
====
The HTML page with the embedded jQuery (see <<jquery_cds>>) is short and the embedded jQuery is likewise
terse compared to the
earlier Twitter sample (see <<twitter>>). The current example shows a jQuery shortcut method, in this
example +getJSON+, that can used in place of the generic jQuery +ajax+ method. 
Of particular interest here, however, is that the jQuery code does not parse the
JSON document returned from the RESTful service but, rather, treats the JSON document as a native
JavaScript array. In the body of the +each+ iteration (line 1), for example, the jQuery extracts
the title and the artist in CD using regular JavaScript syntax:
----
cds[ind].title  /* line 2: ind is the index into the array */ 
cds[ind].artist /* line 3 */                                      
----
No parsing is required.

In the composed 'cds' service, the W3C service is the ultimate data source.
The other service, which consists of the very short JSP script 'getCDs.jsp' (see <<jsp_script>>) and the back-end POJO class
+FetchXML+ (see <<backend_pojo>>), is the fetch-and-convert module: a jQuery client hits the JSP script, which
returns JSON from the +FetchXML+ instance method +getJson+; and the JSON is the result of
transforming XML from the W3C service into JSON.

[[jsp_script]]
.The 'getCDs.jsp' script in the 'cds' service.
====
----
<jsp:useBean id    = "fetcher" 
	     type  = "cds.FetchXML" 
	     class = "cds.FetchXML">  
</jsp:useBean> 
<jsp:getProperty name = "fetcher" property = "json" /> <1>
----
====
When a client request hits the 'getCDs.jsp' script (technically, the servlet instance into which this 
JSP script is ultimately transformed), the client gets in response the value returned from the
+FetchXML+ method +getJson+, named in the JSP script as the property +json+ (line 1).

[[backend_pojo]]
.The back-end POJO class +FetchXML+ and its +getJson+ method.
====
----
package cds;

import org.json.JSONObject;
import org.json.XML;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

public class FetchXML {
    public void setJson(String json) { } 
    public String getJson() {
	JSONObject json = null;
	try {
	    // Fetch the XML document from the W3C site.
	    String xml = "";
	    URL url = new URL("http://www.w3schools.com/xml/cd_catalog.xml");     <1>
	    URLConnection conn  = url.openConnection();                           <2>
	    BufferedReader in = 
		new BufferedReader(new InputStreamReader(conn.getInputStream()));
	    // Read the document records.
	    String line = null;
	    while ((line = in.readLine()) != null) xml += line;                   <3>
	    in.close();
	    xml = xml.replace("'", ""); // Clean up the XML.                      <4>
	    // Transform the XML document into a JSON object.
	    json = XML.toJSONObject(xml.toLowerCase());                           <5>
	}
	catch(Exception e) { throw new RuntimeException(e); }
	return json.toString(); // JSON document                                  <6>
    }
}
----
====   
The +FetchXML+ method +getJson+ uses a +URLConnection+ (line 2) to communicate with the 
W3C service at the designated URL (line 1). The W3C service returns the CD list as an XML document,
which the +FetchXML+ instance reads line by line (line 3). For readability, the
XML document is converted to lower case and otherwise cleaned up (lines 4 and 5) before being
converted into a JSON document (line 6), which is returned to the jQuery script. A
JSON library deployed in the WAR file converts the XML to JSON; and the jQuery
script, which invokes the composed RESTful service to begin, benefits from
receiving JSON rather than XML. If the jQuery script dealt directly with the W3C service, then
this script would take on the task of either parsing the returned XML document or transforming
the XML into JSON.  

==== An Ajax Polling Example

The JAX-RS 'predictions3' web service in Chapter 2 supports all of the CRUD operations, which means that the resource
can change state over time. How should clients against this RESTful service keep abreast of the changes? Two general
ways are available: 

* The service itself might maintain a list of connected clients and automatically 
'push' to these clients any changes in the resource. 

* The clients might periodically poll the service with 
GET request and thereby 'pull' the current representation of the resource. 

The example in this section illustrates the
second approach with a jQuery client that continually polls the 'predictions3' service with GET requests for a JSON
response. The 'predictions3' service is unchanged from Chapter 2.

[[poll_client]]
.The 'poll.html' page with jQuery to poll the 'predictions3' service.
====
----
<!DOCTYPE html>
<html>
  <head>
    <title>Ajax olling example</title>
    <script type = "text/javascript" 
	    src  = "http://code.jquery.com/jquery-latest.min.js">
    </script>
    <script type = "text/javascript">
      var url = 'http://localhost:8080/predictions3/resourcesP/json';
      function displayPreds(preds) {
         $('#container').empty(); // clear the old list, if any
         $.each(preds, function(ind, val) { 
              $('#container').append('<li>' + preds[ind].who + ': ' + 
	                                      preds[ind].what + '</li>'); } );
      }
      function fetch() {
          $.ajax({                                                                <1>
                   url:         url,
                   method:      'GET',                                            <2>
                   dataType:    'json',
                   contentType: "application/json; charset=utf-8",
                   cache:       false,
                   success:     function(res) { displayPreds(res.predictions); },
                   error:       function(res) { console.log(res); },
                   complete:    function () {                                     <3>
                                   setTimeout(function() { fetch() }, 5000)}});   <4>
      }
      $(document).ready(fetch); // invoked after DOM is built and loaded          <5>
    </script>
  </head>
  <body>
    <ul id = 'container'></ul>
  </body>
</html>
----
====

The HTML page 'poll.html' (see <<poll_client>>) embeds a jQuery script that continually polls
the 'predictions3' service. The workhorse function is +fetch+ (line 1), which makes an
Ajax call against the RESTful 'predictions3' 
service. The URL ends with +/json+, which signals that the response should be JSON rather
than XML or plain text. As the key named +method+ and its value indicate (line 2), the Ajax call is
essentially a GET request. This example thus goes back to the generic +ajax+ call rather than
a shortcut call such as +getJSON+.

The Ajax request from +fetch+ has two possible outcomes:

* If the request succeeds, then the predictions are displayed on the HTML page as elements in an unordered list.
* If the request fails, the response message is logged.

In either case, the +complete+ key (line 3) has as its value a function (lines 4 and 5) that invokes
the jQuery +setTimeout+ function; and the +setTimeout+ function pauses for 5 seconds before
invoking +fetch+ yet again. The +complete+ function executes 'after' either the +success+
or the +error+ function has executed. The jQuery script thus polls the 'predictions3' service repeatedly, with
brief pauses in-between each polling operation; and the 'poll.html' page displays, to within 
five seconds or so, the current state of the 'predictions3' resource.

The deployed 'poll.html' page (see the sidebar) can be tested as follows:

* The page can be displayed and thereby checked in a browser. If none of
the predictions has been deleted and no new one has been added, there should be 32 
predictions in all, the last of which should be:
+
----
Hiram Gulgowski: Versatile tangible application will maximize...
----
+

* A 'curl' call then can be used, for example, to delete this prediction, whose
+id+ is 32:
+
----
% curl --request DELETE localhost:8080/predictions3/resourcesP/delete/32
----
+
In about five seconds or so, the 'poll.html' page can be inspected again in the browser to
confirm that the Hiram Gulgowski prediction is gone. Similar 'curl' tests involving
POST and PUT requests should have the expected impact on the browser-displayed
'poll.html'.

.Why deploy the 'poll.html' page as a one-page web site?
****
The ZIP file with the sample code includes a simple web site ('ch3/poll') consisting of two
files, 'poll.html' and 'web.xml'. The site can be deployed in the usual way:
----
% ant -Dwar.name=ajax deploy
----
After deployment, a browser hits the site with the URL
----
http://localhost:8080/ajax/
----
It is tempting to avoid the deployment altogether and, instead, load the local file
'poll.html' into the browser with a URL such as 
----
file:///home/kalin/jwsur2/ch3/poll/poll.html
----
In some browsers, this may be alright but in others (for example, Chrome) the 
'same origin policy', discussed earlier with respect to JSONP, comes into play. In 
the case of Chrome, even two local files in the same directory are treated as
having different origins. The upshot is that Ajax calls in an HTML page such as
'poll.html' should be tested by deploying the page as part of a web site. 
Accordingly, the 'poll.html' page is deployed in the
'ajax.war' file and a browser is then directed to this WAR file.
****

The Ajax polling example, like the earlier 'cds' service, shows the benefit that a
jQuery or other JavaScipt client enjoys from a JSON response. In the polling example,
the +who+ and the +what+ attributes a JSON prediction are extracted
straightforwardly. Here, for review, is the code snippet that displays a prediction
as an HTML element in an unordered list:
----
$('#container').append('<li>' + preds[ind].who + ': ' + 
                        preds[ind].what + '</li>'); } );
----
In an expression such as 
----
preds[ind].who
----
+preds+ refers to the JSON array, 
+ind+ is an integer index into this array, and +who+ is a field in the JSON 
representation of a JavaScript prediction object. The jQuery script can access the
information of interest in a natural way precisely because the script deals with
JSON rather than, say, XML.

JavaScript clients of RESTful web services, such as the jQuery clients illustrated in the three examples of
this section, are becoming increasingly popular. RESTful services are sufficiently flexible to generate
response payloads in whatever format a client prefers. In the case of JavaScript clients, the preferred
format is clear: JSON.

=== What's Next?

The focus in the first three chapters has been on RESTful web services and their clients. The next
chapter turns to SOAP-based services delivered over HTTP(S), which can be viewed as a special case
of RESTful services. The normal request and response payloads in a SOAP-based service are
'SOAP envelopes', XML documents whose root element has a tag with +Envelope+ as the local name. An
example is:
-----
<soap:Envelope xmlns:soap = '...'>
  ...
</soap:Envelope>
----
In a typical SOAP-based exchange, a client sends an +Envelope+ to a service and gets an
+Envelope+ in return. SOAP, like XML in general, is programming-language neutral; and any language 
with the appropriate libraries can support
SOAP-based services and clients. At present, however, only Java and DotNet have strong support for
SOAP; the other language systems have spotty support at best.

There is much to be said for SOAP over HTTP. The HTTP handles the transport and, in the case of HTTPS,
addresses major wire-level security concerns. The SOAP libraries on the service and the client
side typically hide the SOAP, although the SOAP is available to inspect or even manipulate
if a service or a client requires this. Chapter 4 looks at the service and the client sides of 
SOAP-based services; and this look includes two SOAP-based clients against the Amazon E-Commerce service.
Chapter 5 then examines the 'handler level' in SOAP-based services. At the 'application level' in
SOAP-based services, the SOAP itself is transparent; at the 'handler level', the SOAP is exposed for
examination and manipulation.
